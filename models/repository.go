// Copyright (C) 2022 Check Point Software Technologies Ltd. All rights reserved.

// Licensed under the Apache License, Version 2.0 (the "License");
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package models

import (
	"encoding/json"
)

// Values list of values
type Values []string

// ValuesWithTime a pair of values and last modified unix timestamp
type ValuesWithTime struct {
	First  Values `json:"first"`
	Second int64  `json:"second"`
}

// MapKeyValue cereal representation of a map for confidence set
type MapKeyValue struct {
	Key   string         `json:"key"`
	Value ValuesWithTime `json:"value"`
}

// ValueWithLevel a pair of values and confidence level
type ValueWithLevel struct {
	Key   string  `json:"key"`
	Value float64 `json:"value"`
}

// MapKeyValueLevel cereal representation of a map for confidence level
type MapKeyValueLevel struct {
	Key   string           `json:"key"`
	Value []ValueWithLevel `json:"value"`
}

// ConfidenceData the content of confidence file generated by the agent
type ConfidenceData struct {
	ConfidenceSet    []MapKeyValue      `json:"confidence_set"`
	ConfidenceLevels []MapKeyValueLevel `json:"confidence_levels"`
}

// SyncType Enum representing the underlying data to sync
type SyncType string

// Enum of sync types
const (
	ScannersDetector     SyncType = "ScannersDetector"
	IndicatorsConfidence SyncType = "Indicators/Confidence"
	IndicatorsTrusted    SyncType = "Indicators/Trust"
	TypesConfidence      SyncType = "Type/Confidence"
	TypesTrusted         SyncType = "Type/Trust"
	CentralizedData      SyncType = "CentralizedData"
)

// SyncTypes is an iterable list of known sync types for centralized data processing
var SyncTypes = []SyncType{
	ScannersDetector,
	IndicatorsConfidence,
	IndicatorsTrusted,
	TypesConfidence,
	TypesTrusted,
}

// SyncID contain all the data that defines the sync operation
type SyncID struct {
	TenantID string
	AssetID  string
	Type     SyncType
	WindowID string
}

// SyncLearnNotificationConsumers is sync data payload
type SyncLearnNotificationConsumers struct {
	AssetID  string   `json:"assetId"`
	Type     SyncType `json:"type"`
	WindowID string   `json:"windowId"`
}

// CentralData is the struct for centralized data collection, matching the expected JSON
// Uses []*string for pointer-based deduplication
type CentralData struct {
	TrustedSources []*string              `json:"trustedSources"`
	Logger         map[string]LoggerEntry `json:"logger"`
}

// CentralDataWrapper is a wrapper for CentralData to match the JSON structure
type CentralDataWrapper struct {
	Data *CentralData `json:"unifiedIndicators"`
}

// UnmarshalJSON customizes the JSON unmarshalling for CentralData
// Deduplicates trusted sources using pointers at unmarshal time
func (c *CentralData) UnmarshalJSON(data []byte) error {
	type rawCentralData struct {
		Logger         map[string]LoggerEntry `json:"logger"`
		TrustedSources []string               `json:"trustedSources"`
	}
	var raw rawCentralData
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}

	// String pool for deduplication of trusted sources
	stringPool := make(map[string]*string)

	getOrCreate := func(s string) *string {
		if ptr, ok := stringPool[s]; ok {
			return ptr
		}
		str := s
		stringPool[str] = &str
		return stringPool[str]
	}

	// Deduplicate TrustedSources
	c.TrustedSources = make([]*string, 0, len(raw.TrustedSources))
	for _, src := range raw.TrustedSources {
		c.TrustedSources = append(c.TrustedSources, getOrCreate(src))
	}

	// Logger entries already unmarshaled (each entry deduplicates internally)
	c.Logger = raw.Logger
	return nil
}

// LoggerEntry represents a single entry in the logger with total sources, indicators, and types
// Uses []*string for pointer-based string deduplication at unmarshal time
type LoggerEntry struct {
	TotalSources []*string            `json:"totalSources"`
	Indicators   map[string][]*string `json:"indicators"`
	Types        map[string][]*string `json:"types"`
}

// UnmarshalJSON customizes the JSON unmarshalling for LoggerEntry
// It deduplicates strings at unmarshal time using pointers to reduce memory usage
func (l *LoggerEntry) UnmarshalJSON(data []byte) error {
	type rawLoggerEntry struct {
		TotalSources []string            `json:"totalSources"`
		Indicators   map[string][]string `json:"indicators"`
		Types        map[string][]string `json:"types"`
	}
	var raw rawLoggerEntry
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}

	// String pool for deduplication within this logger entry
	stringPool := make(map[string]*string)

	getOrCreate := func(s string) *string {
		if ptr, ok := stringPool[s]; ok {
			return ptr
		}
		// Create a new string and store pointer in pool
		str := s
		stringPool[str] = &str
		return stringPool[str]
	}

	// Deduplicate TotalSources
	l.TotalSources = make([]*string, 0, len(raw.TotalSources))
	for _, src := range raw.TotalSources {
		l.TotalSources = append(l.TotalSources, getOrCreate(src))
	}

	// Deduplicate Indicators
	l.Indicators = make(map[string][]*string, len(raw.Indicators))
	for key, arr := range raw.Indicators {
		ptrSlice := make([]*string, 0, len(arr))
		for _, v := range arr {
			ptrSlice = append(ptrSlice, getOrCreate(v))
		}
		l.Indicators[key] = ptrSlice
	}

	// Deduplicate Types
	l.Types = make(map[string][]*string, len(raw.Types))
	for key, arr := range raw.Types {
		ptrSlice := make([]*string, 0, len(arr))
		for _, v := range arr {
			ptrSlice = append(ptrSlice, getOrCreate(v))
		}
		l.Types[key] = ptrSlice
	}
	return nil
}
